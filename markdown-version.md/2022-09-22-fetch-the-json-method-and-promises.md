---
title: "Fetch, the .json method and Promises"
date: "2022-09-22"
categories: 
  - "software-engineering"
---

## Introduction

After three weeks of learning Javascript I had a good handle on most basic local operations, and was feeling increasingly confident about simple asynchronous operations. This one, which retrieves book data from a source and creates objects for each book, is an ordinary example:

```
fetch('http://localhost:3000/books')
    .then(res => res.json())
    .then(bookData => {
        bookData.forEach(createListElement)
})
```

Fetch statements interact with outside data sources, though in this example it is referencing a server set up on the local machine. That part was easy for me to grasp. .then statements handle asychronous data, which was also easy to grasp given that the data is (usually) coming from a computer far away, and there are many unknowns about when or if the data will be recieved.

.then statements return a _Promise_, which will resolve to some kind of information from the server once the communication is complete.

My first understanding of .json was that it is the process by which JSON data, which has slightly different syntax, is converted into a Javascript object. Therefore, it is easy to understand how the .then statement waits for the data to be recieved and then feeds it into the .json method.

So far, so good. But, you can see _two_ .then statements. One is waiting for the response from the outside data source, but then one appears to be waiting for the result of the .json method. If .json is doing a relatively simple operation of changing a few items of syntax, why then does it need to be behind a .then statement, which represents waiting on an asynchronous source?

As my Google-fu for programming improved, I learned that I was wrong about what .json does.

## Different Promises

The fetch() method returns a Promise, which resolves into a Response. In this example, using the free API ageify.io, which takes in a name and puts out the most likely age of a person with that name:

```
fetch('https://api.agify.io?name=Horatio')
    .then (res => console.log(res))
```

the console log of the return looks like this:

```
Response {type: 'cors', url: 'https://api.agify.io/?name=Horatio', redirected: false, status: 200, ok: true, â€¦}
body: ReadableStream
bodyUsed: false
headers: Headers {}
ok :true
redirected: false
status: 200
statusText: "OK"
type: "cors"
url: "https://api.agify.io/?name=Horatio"
[[Prototype]]: Response
```

which is full of information about the server response, but the key point is that the body is listed as ReadableStream, which is an object type used for gradually collecting data from a remote source, the details of which are beyond the scope of this article. Even though the local machine has already waited for the server's Promise to be fulfilled, all it has recieved is the information _about_ the data I want, not the data itself. There is not yet anything to be converted. Then, we come to the second .then:

```
fetch('https://api.agify.io?name=Horatio')
    .then (res => res.json())
    .then (data => console.log(data))
```

The second .then read the Promise generated by the first, and continued to wait for the data to arrive before giving it the name "data" and putting it in the console log:

```
{age: 64, count: 175, name: 'Horatio'}
```

Finally, the data! Now I can know that the statistically average Horatio across their international data is 64 years old.

## Conclusion

Through a better understanding of Promises I have come to understand better why it takes two of them to retrieve data from a remote source. I hope this artucle can give someone out there who was as confused as I was a breakthrough moment.

## References

- [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- [https://developer.mozilla.org/en-US/docs/Web/API/fetch](https://developer.mozilla.org/en-US/docs/Web/API/fetch)
- [https://agify.io/](https://agify.io/)
